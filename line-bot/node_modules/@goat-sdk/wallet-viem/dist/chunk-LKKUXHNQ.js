"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }var v=Object.defineProperty;var p=(s,t)=>v(s,"name",{value:t,configurable:!0});var _walletevm = require('@goat-sdk/wallet-evm');var _viem = require('viem');var _chains = require('viem/chains');var _zksync = require('viem/zksync');var l=class extends _walletevm.EVMWalletClient{static{p(this,"ViemEVMWalletClient")}#t;#a;#n;get publicClient(){return this.#t.extend(_viem.publicActions)}constructor(t,a){super(),this.#t=t,this.#a=_nullishCoalesce(_optionalChain([a, 'optionalAccess', _ => _.paymaster, 'optionalAccess', _2 => _2.defaultAddress]), () => ("")),this.#n=_nullishCoalesce(_optionalChain([a, 'optionalAccess', _3 => _3.paymaster, 'optionalAccess', _4 => _4.defaultInput]), () => (_zksync.getGeneralPaymasterInput.call(void 0, {innerInput:"0x"})))}getAddress(){return _nullishCoalesce(_optionalChain([this, 'access', _5 => _5.#t, 'access', _6 => _6.account, 'optionalAccess', _7 => _7.address]), () => (""))}getChain(){return{type:"evm",id:_nullishCoalesce(_optionalChain([this, 'access', _8 => _8.#t, 'access', _9 => _9.chain, 'optionalAccess', _10 => _10.id]), () => (0))}}async signMessage(t){if(!this.#t.account)throw new Error("No account connected");return{signature:await this.#t.signMessage({message:t,account:this.#t.account})}}async signTypedData(t){if(!this.#t.account)throw new Error("No account connected");return{signature:await this.#t.signTypedData({domain:{...t.domain,chainId:typeof t.domain.chainId=="bigint"?Number(t.domain.chainId):t.domain.chainId},types:t.types,primaryType:t.primaryType,message:t.message,account:this.#t.account})}}async sendTransaction(t){let{to:a,abi:n,functionName:e,args:i,value:r,options:y,data:g}=t;if(!this.#t.account)throw new Error("No account connected");let w=a,c=_nullishCoalesce(_optionalChain([y, 'optionalAccess', _11 => _11.paymaster, 'optionalAccess', _12 => _12.address]), () => (this.#a)),o=_nullishCoalesce(_optionalChain([y, 'optionalAccess', _13 => _13.paymaster, 'optionalAccess', _14 => _14.input]), () => (this.#n)),u=!!c&&!!o,f=u?this.#t.extend(_zksync.eip712WalletActions.call(void 0, )):this.#t;if(!n){let d={account:this.#t.account,to:w,chain:this.#t.chain,value:r,data:g,...u?{paymaster:c,paymasterInput:o}:{}},m=await f.sendTransaction(d);return this.waitForReceipt(m)}if(!e)throw new Error("Function name is required for contract calls");let{request:h}=await this.publicClient.simulateContract({account:this.#t.account,address:w,abi:n,functionName:e,args:i,chain:this.#t.chain,value:r});if(u){let d=_viem.encodeFunctionData.call(void 0, {abi:n,functionName:e,args:i}),m={account:this.#t.account,chain:this.#t.chain,to:h.address,data:d,value:h.value,paymaster:c,paymasterInput:o},C=await f.sendTransaction(m);return this.waitForReceipt(C)}let b=await this.#t.writeContract(h);return this.waitForReceipt(b)}async read(t){let{address:a,abi:n,functionName:e,args:i}=t;if(!n)throw new Error("Read request must include ABI for EVM");return{value:await this.publicClient.readContract({address:a,abi:n,functionName:e,args:i})}}async balanceOf(t){let a=await this.publicClient.getBalance({address:t}),n=_nullishCoalesce(this.#t.chain, () => (_chains.mainnet));return{value:_viem.formatUnits.call(void 0, BigInt(a),n.nativeCurrency.decimals),decimals:n.nativeCurrency.decimals,symbol:n.nativeCurrency.symbol,name:n.nativeCurrency.name,inBaseUnits:a.toString()}}async waitForReceipt(t){let a=await this.publicClient.waitForTransactionReceipt({hash:t});return{hash:a.transactionHash,status:a.status}}};function q(s,t){return new l(s,t)}p(q,"viem");exports.a = l; exports.b = q;
